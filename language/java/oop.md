# oop

面向对象编程（Object-Oriented Programming，OOP）。

面向对象的三大特性封装、继承、多态。（抽象，四大特性）。

抽象是对业务的建模能力、以及对架构的宏观把控能力。

封装是一种对象功能内聚的表现形式，是模块耦合度降低。

继承使模块更具复用性。

多态使模块在复用性基础上更加有扩展性，使运行期更有想象空间。  

面向过程让计算机有步骤地顺次做一件事情 ， 是种过程化的叙事思维。  

面向对象提出一种计算机世界里解决复杂软件工程的方法论，拆解问题复杂度，从人类思维角度提出解决问题的步骤和方案。  

比如 ”开门“这个动作，面向过程是 ”open(Door door)", “door”是被作为操作对象的参数传入方法的 ， 方法内定义开门的具体步骤实现。而在面向对象的世界里 ，首先定义一个对象 “ Door ” ， 然后抽象出门的属性和相关操作，属性包括门的尺寸、颜色、开启方式（往外开还是往内开）、防盗功能等，门这个对象的操作必然包括open () 和 close() 两个必备的行为。面向过程的结构相对松散 ， 强调如何流程化地解决问题；面向对象的思维更加内聚，强调高内聚、低藕合，先抽象模型，定义共性行为 ，再解决实际问题。  

___

Object 类，是任何类的默认父类，是对万事万物的抽象，是在哲学方向上进行的延伸思考，高度概括了事物的自然行为和社会行为。我们都知道哲学的三大经典问题我是谁，我从哪里来，我到哪里去。在 Object 类中，这些问
题都可以得到隐约的解答。



( I ）我是谁？ getClass()说明本质上是谁，而 toString()是当前职位的名片。
( 2 ）我从哪里来？ Object()构造方法是生产对象的基本步骤， clone()是繁殖对象的另一种方式。
( 3 ）我到哪里去？ finalize()是在对象销毁时触发的方法。  

___

clone()方法，它分为浅拷贝、一般深拷贝和彻底深拷贝。浅拷贝只复制当前对象的所有基本数据类型，以及相应的引用变量，但没有复制引用变量指向的实际对象；而彻底深拷贝是在成功 clone一个对象之后，此对象与母对象在任何引用路径上都不存在共享的实例对象 ，但是引用路径递归越深，则越接近 JVM 底层对象 ， 且发现彻底深拷贝实现难度越大。介于浅拷贝和彻底深拷贝之间的都是一般深拷贝。归根结底 ，慎用 Object 的 clone() 方法来拷贝对象，因为对象的 clone()方法默认是浅拷贝，若想实现深拷贝，则需要覆写 clone() 方法实现引用对象的深度遍历式拷贝。  

---

另外， object还映射了社会科学领域的一些问题：
( I ) 世界是否在因你而不同？ hashCode()和 equals()就是判断与其他元素是否相同的一组方法。
( 2 ）与他人如何协调？ wait()和 notify()是对象间通信与协作的一组方法。  



---

继承是 is-a 关系，那么如何衡量当前的继承关系是否满足 is-a 关系呢？判断标准即是否符合里氏代换原则（ Liskov Substitution Principle, LSP ）。 LSP 是指任何父类能够出现的地方，子类都能够出现。 

谨慎使用继承 ，认清继承滥用的危害性，即方法污染和方法爆炸。

方法污染是指父类具备的行为 ， 通过继承传递给子类，子类并不具备执行此行为的能力 ，比如鸟会飞，驼鸟继承鸟 ， 发现飞不了，这就是方法污染。   

方法爆炸是指继承树不断扩大，底层类拥有的方法虽然都能够执行，但是由于方法众多，其中部分方法并非与当前类的功能定位相关，很容易在实际编程中产生选择困难症。  

综上所述 ， 提倡组合优先原则来扩展类的能力，即优先采用组合或聚合的类关系来复用其他类的能力，而不是继承。  

---

多态是以上述的三个面向对象特性为基础，根据运行时的实际对象类型，同一个方法产生不同的运行结果，使同一个行为具有不同的表现形式。多态提升了对象的扩展能力和运行时的丰富想象力。  

“override”和 “overload”：“ override ” 译成 “ 覆写 ”，是子类实现接口，或者继承父类时，保持方法签名完全相同，实现不同的方法体，是垂直方向上行为的不同实现。 “overload”译成“重载”，方法名称是相同的，但是参数
类型或参数个数是不相同的，是水平方向上行为的不同实现。

多态是指在编译层面无法确定最终调用的方法体 ， 以覆写为基础来实现面向对象特性，在运行期由JVM进行动态绑定，调用合适的覆写方法体来执行。重载是编译期确定方法调用，属于静态绑定，本质上重载的结果是完全不同的方法，所以本书认为多态专指覆写。

